#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <limits>
#include <iterator>
#include <cctype>
#include <algorithm>
#include <vector>
#include <map>
#include <math.h>
#include <list>
#include "seqinf.h"
#include "para.h"
#include "settings.h"
#include "function.h"

using namespace std;

double nn(double n){return (n>0)?n:0;}

double rel_ent(vector<double> freq,double inv,double gamma,int tree)
{
	int index[]={18,35,52,21,41,61,7,8,10,12,14,15,19,20,23,24,25,26,27,28,29,30,31,32,34,36,37,38,39,40,42,44,45,46,47,48,50,51,53,54,55,56,57,58,59,60,62,63};
	if(tree==2)
	{
		index[0]=6;
		index[1]=11;
		index[2]=16;
	}
	if(tree==3)
	{
		index[3]=6;
		index[4]=11;
		index[5]=16;
	}
	
	vector<double> u=freq;
	int i;
	double tmp;
	hadamard_64(u);
	for(i=0;i<64;i++)
	{
		tmp=(u[i]-inv)/(1-inv);
		tmp=pow(tmp,-1/gamma)-1;
		u[i]=tmp;
	}
	hadamard_64(u);
	
	for(i=0;i<64;i++){u[i]=u[i]/64;if(u[i]>0){u[i]=0;}}
	for(i=0;i<42;i++){u[index[i]-1]=0;}
	u[0]=0;
	for(i=0;i<64;i++){u[0]-=u[i];}
	
	hadamard_64(u);
	for(i=0;i<64;i++)
	{
		tmp=u[i];
		u[i]=(pow(1+tmp,-gamma))*(1-inv)+inv;
	}
	hadamard_64(u);
	for(i=0;i<64;i++){u[i]=u[i]/64;}
	tmp=0;
	for(i=0;i<64;i++){if(freq[i]>0){tmp+=freq[i]*(log(u[i])-log(freq[i]));}}
	return tmp;
}

void qnetoutput(seqinf seqs,para var_parameter,vector<vector<double> > allfreq,settings globalsettings)
{
	cout<<endl<<"outputing sequences to file "<<globalsettings.getoutfile()<<endl;
	ofstream fout(globalsettings.getoutfile().c_str());
	fout<<"taxanumber: "<<seqs.gettaxa_n()<<";\n";
	fout<<"description: quartet weights generated by Hadamard conjugate;"<<endl;
	int i=0,m,n,o,p;
	for(i=1;i<=seqs.gettaxa_n();i++){fout<<"taxon:   "<<i<<"   name:"<<seqs.getname(i)<<";"<<endl;}
	
	
	vector<double> v_tmp(64);
	double inv=var_parameter.getinv();
	double gamma=var_parameter.getgamma();
	double d_tmp;
	int taxan=seqs.gettaxa_n();
	i=0;
	
	for(m=1;m<=taxan;m++)
	{
		for(n=m+1;n<=taxan;n++)
		{
			for(o=n+1;o<=taxan;o++)
			{
				for(p=o+1;p<=taxan;p++)
				{
					fout<<"quartet: "<<m<<" "<<n<<" "<<o<<" "<<p<<" weights: ";
					//cout<<i<<endl;
					for(int t=0;t<64;t++){v_tmp[t]=allfreq[i][t];}
					hadamard_64(v_tmp);
					for(int t=0;t<64;t++)
					{
						d_tmp=(v_tmp[t]-inv)/(1-inv);
						d_tmp=pow(d_tmp,-1/gamma)-1;
						v_tmp[t]=d_tmp;
					}
					hadamard_64(v_tmp);
					fout<<(-v_tmp[5]-v_tmp[10]-v_tmp[15])*(1-inv)*gamma<<' ';
					fout<<(-v_tmp[17]-v_tmp[34]-v_tmp[51])*(1-inv)*gamma<<' ';
					fout<<(-v_tmp[20]-v_tmp[40]-v_tmp[60])*(1-inv)*gamma<<";"<<endl;
					i++;
				}
			}
		}
	}

	fout.close();
	cout<<endl<<"output complete."<<endl;
}


void clannoutput(seqinf seqs,para var_parameter,std::vector<std::vector<double> > allfreq,settings globalsettings)
{
	cout<<endl<<"outputing sequences to file "<<globalsettings.getoutfile()<<endl;
	ofstream fout(globalsettings.getoutfile().c_str());
	int i=0,m,n,o,p,taxan=seqs.gettaxa_n();
	double i1,i2,i3,min;
	double inv=var_parameter.getinv();
	double gamma=var_parameter.getgamma();
		
	for(m=1;m<=taxan;m++)
	{
		for(n=m+1;n<=taxan;n++)
		{
			for(o=n+1;o<=taxan;o++)
			{
				for(p=o+1;p<=taxan;p++)
				{
					i1=rel_ent(allfreq[i],inv,gamma,1);
					i2=rel_ent(allfreq[i],inv,gamma,2);
					i3=rel_ent(allfreq[i],inv,gamma,3);
					min=(i1<i2?i1:i2);
					min=min<i3?min:i3;
					i1-=min;
					i2-=min;
					i3-=min;
					if(i1>1e-6){fout<<"(("<<seqs.getname(m)<<","<<seqs.getname(n)<<"),"<<seqs.getname(o)<<","<<seqs.getname(p)<<") ["<<i1<<"];"<<endl;}
					if(i2>1e-6){fout<<"(("<<seqs.getname(m)<<","<<seqs.getname(o)<<"),"<<seqs.getname(n)<<","<<seqs.getname(p)<<") ["<<i2<<"];"<<endl;}
					if(i3>1e-6){fout<<"(("<<seqs.getname(m)<<","<<seqs.getname(p)<<"),"<<seqs.getname(n)<<","<<seqs.getname(o)<<") ["<<i3<<"];"<<endl;}
					i++;
				}
			}
		}
	}

	fout.close();
	cout<<endl<<"output complete."<<endl;

}

